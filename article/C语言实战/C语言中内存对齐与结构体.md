- [一、结构体](#一结构体)
- [二、内存对齐](#二内存对齐)
  - [1、结构体大小](#1结构体大小)
  - [2、下面举例论证结构体大小](#2下面举例论证结构体大小)
    - [2.1、简单结构体](#21简单结构体)
    - [2.2、借用(1)中的结构体](#22借用1中的结构体)
    - [2.3、借用(1)中的结构体](#23借用1中的结构体)
- [三、说明](#三说明)

继续学习 C 语言中的知识，对于 Linux C/C++ 方面需要什么资料，后台回复一下，希望大家可以坚持学 C。

## 一、结构体

结构体是一种新的数据类型，对C语言的数据类型进行了极大的扩充。

```c
struct STU{
  int age;
  char name[15];
 };

 struct STU  a;   //结构体实例
 struct STU  *b;  //结构体指针

```

1. 可以通过a.age对其进行取成员的操作，b->age也可以进行结构体的操作，b->age存在问题，必须有一个结构体空间已经让b指向，b的值为此结构体空间的地址。
2. a.name = "lilei"; false,因为name是数组名称，指针常量不能赋值，解决方案：strcpy()函数
3. 字符串直接进行比较的话，是其地址的比较，没有什么意义，用strcmp()函数进行比较，就是ASCII码的比较了。

## 二、内存对齐

操作系统对于内存空间的分配，遵循如下原则：**总是从2^n倍数为地址的字节处开始分配空间。**

如：若按4B对其模式的话，则每个变量(结构体成员)的首地址总是从编号为4的整数倍的字节处开始分配空间。

可设几字节对齐如下

```c
#pragma pack(push)    //保持原对齐格式
#pragma pack(1)      //设定为n字节格式

 .......
 
#pragma pack(pop)     //恢复为原对齐格式
```

### 1、结构体大小

1. 总大小是下一个类型的整数倍，否则用单字节补齐(单字节最多补到4/8，具体看结构体中最宽几字节），总大小指的是前面字节总数和当前的字节数之和；
2. 结构体大小是最宽字节的整数倍(一般情况下为4或8)；
3. 上述两个条件必须同时成立。若最终结果不成立的话，则补齐整数倍即可。

### 2、下面举例论证结构体大小

#### 2.1、简单结构体

```c
struct TEST{
    int a;
    short b;
    char c;
    struct TEST *next;
};
```

分析如下：4->2->1 (补1字节)->4   共12字节;

#### 2.2、借用(1)中的结构体

```c
struct TEST1{
  short d;
  int e;
  char f;
  struct TEST g;
  struct TEST1 *next;
  struct TEST h;
  char i;
};
```

分析如下：2(补2字节)->4->1(补3字节)->12->4(**想补也不能补，最多补到最宽单字节，在这最多到4字节，已经为4字节了，所以不能在补了**)->12->1。

一共为：41字节，但是结构体大小为最宽单字节的整数倍，在这应为4的整数倍，最终，此结构体大小为44字节。

#### 2.3、借用(1)中的结构体

```c
struct TEST2{
  short d;
  int e;
  double f;
  struct TEST1 *next;
  struct TEST g;
  char i;
};

```

分析如下：2(补2字节)->4->8->4(**补4字节：前面一共16字节，当前4字节，所以总共20字节，不是下一个数据类型(12)的整数倍，且最宽为8字节，可补4字节，构成整数倍**)->12->1。

一共为37字节，但是结构体大小为最宽单字节的整数倍，在这应为8的整数倍，最终此结构体大小为40字节。

结构体类型极大的扩充了C语言，是数据类型更加丰富多彩。

## 三、说明

原创文章链接：[C语言中内存对齐与结构体！](https://mp.weixin.qq.com/s?__biz=MzUxMzkyNDk0Ng==&mid=2247483726&idx=1&sn=7617f22faf6bab48b1a6c1e2036a6acf&chksm=f94c8b73ce3b02650d864d9267ae3f88c37603995990a25bd8eda3541724185618ec81be7cde&scene=21#wechat_redirect)
